break_expression
extern
type_parameters
struct_item
union_item
type_parameters_repeat1
attribute_item
field_expression
where_clause
let_declaration
escape_sequence
_pattern
for_lifetimes
"
enum_variant
string_literal_repeat1
&
where_predicate
token_binding_pattern
token_tree_pattern_repeat1
binary_expression
field_declaration_list
tuple_expression
in
higher_ranked_trait_bound
path
block_comment
-=
=>
range_pattern
as
use_wildcard
captured_pattern
tuple_type_repeat1
char_literal
expr
...
<<=
&&
token_repetition_pattern_token1
->
stmt
field_identifier
scoped_identifier
macro_definition
const_item
array_expression
remaining_field_pattern
*
async_block
type_cast_expression
tuple_type
enum_variant_list
use_declaration
metavariable
unary_expression
trait_item
variadic_parameter
static
range_expression
for_lifetimes_repeat1
trait_bounds_repeat1
match_block_repeat1
match_block
boolean_literal
assignment_expression
fn
mutable_specifier
match_expression
compound_assignment_expr
@
mod_item
declaration_list_repeat1
^=
..=
enum
await
vis
while
tuple_pattern
loop_expression
self
field_initializer_list_repeat1
await_expression
_non_special_token_token1
self_parameter
crate
primitive_type
struct_expression
loop_label
bracketed_type
enum_variant_list_repeat2
field_initializer_list
use_list_repeat1
let
|
]
.
associated_type
else
&=
constrained_type_parameter
ty
ordered_field_declaration_list
fragment_specifier
array_expression_repeat1
function_modifiers
qualified_type
async
#
union
extern_modifier
macro_rules!
shorthand_field_initializer
_string_content
[
continue
end
parameters
field_pattern
const
struct_pattern
try_expression
inner_attribute_item
false
token_repetition
<=
_token_pattern
true
visibility_modifier
enum_variant_list_repeat1
token_tree
:
string_literal
closure_parameters_repeat1
move
for
where_clause_repeat1
raw_string_literal
call_expression
+
line_comment
meta
_expression_statement
meta_arguments
token_tree_pattern
mut_pattern
source_file
scoped_type_identifier
ident
'
if_expression
ERROR
extern_crate_declaration
arguments
dynamic_type
$
field_declaration
struct
ref
closure_expression
default
optional_type_parameter
ordered_field_declaration_list_repeat1
abstract_type
empty_statement
use
_literal
source_file_repeat1
_type
parameters_repeat1
-
_use_clause
lifetime
reference_pattern
struct_pattern_repeat1
loop
base_field_initializer
index_expression
const_block
trait
_statement
==
ref_pattern
mod
enum_item
>
bounded_type
>>=
generic_function
removed_trait_bound
!
?
{
meta_item
if_let_expression
return_expression
generic_type_with_turbofish
function_type
>>
..
pub
=
|=
type_arguments_repeat1
%=
||
;
float_literal
return
slice_pattern
scoped_use_list
_expression
>=
or_pattern
)
type_binding
unit_type
identifier
type_item
for_expression
_literal_pattern
token_repetition_pattern
function_item
pointer_type
tt
unsafe_block
else_clause
if
reference_type
tuple_struct_pattern
}
field_declaration_list_repeat1
/=
*=
%
super
shorthand_field_identifier
where
impl_item
function_signature_item
/
macro_rule
declaration_list
dyn
reference_expression
closure_parameters
function_modifiers_repeat1
token_tree_repeat1
macro_definition_repeat1
parameter
array_type
impl
_
while_let_expression
tuple_expression_repeat1
meta_arguments_repeat1
foreign_mod_item
static_item
!=
empty_type
tuple_pattern_repeat1
break
+=
type_identifier
match
pat
continue_expression
block
unsafe
::
field_initializer
parenthesized_expression
match_arm
const_parameter
generic_type
<
,
macro_invocation
match_pattern
unit_expression
use_list
while_expression
arguments_repeat1
integer_literal
use_as_clause
^
negative_literal
type_arguments
item
trait_bounds
<<